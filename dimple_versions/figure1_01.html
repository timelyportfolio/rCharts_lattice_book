<!doctype HTML>
<meta charset = 'utf-8'>
<html>
  <head>
    
    <script src='http://d3js.org/d3.v3.min.js' type='text/javascript'></script>
    <script src='http://dimplejs.org/dist/dimple.v1.1.4.min.js' type='text/javascript'></script>
    <script src='http://timelyportfolio.github.io/rCharts_dimple_systematic/libraries/widgets/dimple/js/d3-grid.js' type='text/javascript'></script>
    
    <style>
    .rChart {
      display: block;
      margin-left: auto; 
      margin-right: auto;
      width: 800px;
      height: 700px;
    }  
    </style>
    
  </head>
  <body >
    
    <div id = 'chart1d742a0229cb' class = 'rChart dimple'></div>    
    <script type="text/javascript">
(function(){
  var opts = {
 "dom": "chart1d742a0229cb",
"width":    800,
"height":    700,
"xAxis": {
 "type": "addCategoryAxis",
"showPercent": false 
},
"yAxis": {
 "type": "addMeasureAxis",
"showPercent": false,
"overrideMin":      0,
"overrideMax": 0.71686,
"outputFormat": ".2%" 
},
"zAxis": [],
"colorAxis": [],
"defaultColors": [],
"layers": [],
"legend": [],
"x": "gcsescore",
"y": "count",
"groups": "score",
"type": "bar",
"facet": {
 "x": "score",
"nrow":      2,
"ncol":      3 
},
"id": "chart1d742a0229cb" 
},
    data = [{"score":0,"gcsescore":0.5,"count":0},{"score":0,"gcsescore":1,"count":0.000542299349240781},{"score":0,"gcsescore":1.5,"count":0.000542299349240781},{"score":0,"gcsescore":2,"count":0},{"score":0,"gcsescore":2.5,"count":0.00162689804772234},{"score":0,"gcsescore":3,"count":0.0103036876355748},{"score":0,"gcsescore":3.5,"count":0.0330802603036876},{"score":0,"gcsescore":4,"count":0.0905639913232104},{"score":0,"gcsescore":4.5,"count":0.176247288503254},{"score":0,"gcsescore":5,"count":0.376898047722343},{"score":0,"gcsescore":5.5,"count":0.49295010845987},{"score":0,"gcsescore":6,"count":0.476681127982646},{"score":0,"gcsescore":6.5,"count":0.260303687635575},{"score":0,"gcsescore":7,"count":0.06941431670282},{"score":0,"gcsescore":7.5,"count":0.00867678958785249},{"score":0,"gcsescore":8,"count":0.00216919739696312},{"score":2,"gcsescore":0.5,"count":0},{"score":2,"gcsescore":1,"count":0},{"score":2,"gcsescore":1.5,"count":0},{"score":2,"gcsescore":2,"count":0},{"score":2,"gcsescore":2.5,"count":0},{"score":2,"gcsescore":3,"count":0.00661703887510339},{"score":2,"gcsescore":3.5,"count":0.00606561896884478},{"score":2,"gcsescore":4,"count":0.03584229390681},{"score":2,"gcsescore":4.5,"count":0.0744416873449131},{"score":2,"gcsescore":5,"count":0.218362282878412},{"score":2,"gcsescore":5.5,"count":0.417424869037772},{"score":2,"gcsescore":6,"count":0.62531017369727},{"score":2,"gcsescore":6.5,"count":0.409704990350152},{"score":2,"gcsescore":7,"count":0.180314309346567},{"score":2,"gcsescore":7.5,"count":0.0253653156878963},{"score":2,"gcsescore":8,"count":0.000551419906258616},{"score":4,"gcsescore":0.5,"count":0},{"score":4,"gcsescore":1,"count":0.000432994154578913},{"score":4,"gcsescore":1.5,"count":0},{"score":4,"gcsescore":2,"count":0},{"score":4,"gcsescore":2.5,"count":0},{"score":4,"gcsescore":3,"count":0.000865988309157826},{"score":4,"gcsescore":3.5,"count":0.00346395323663131},{"score":4,"gcsescore":4,"count":0.0142888071011041},{"score":4,"gcsescore":4.5,"count":0.0454643862307859},{"score":4,"gcsescore":5,"count":0.128166269755358},{"score":4,"gcsescore":5.5,"count":0.28274518294003},{"score":4,"gcsescore":6,"count":0.586707079454427},{"score":4,"gcsescore":6.5,"count":0.544273652305694},{"score":4,"gcsescore":7,"count":0.329075557479974},{"score":4,"gcsescore":7.5,"count":0.0606191816410478},{"score":4,"gcsescore":8,"count":0.00389694739121022},{"score":6,"gcsescore":0.5,"count":0.000348492768775048},{"score":6,"gcsescore":1,"count":0},{"score":6,"gcsescore":1.5,"count":0},{"score":6,"gcsescore":2,"count":0.000348492768775048},{"score":6,"gcsescore":2.5,"count":0},{"score":6,"gcsescore":3,"count":0.000348492768775048},{"score":6,"gcsescore":3.5,"count":0.00174246384387524},{"score":6,"gcsescore":4,"count":0.00696985537550096},{"score":6,"gcsescore":4.5,"count":0.0209095661265029},{"score":6,"gcsescore":5,"count":0.0627286983795086},{"score":6,"gcsescore":5.5,"count":0.166579543474473},{"score":6,"gcsescore":6,"count":0.443979787419411},{"score":6,"gcsescore":6.5,"count":0.607074403206133},{"score":6,"gcsescore":7,"count":0.516466283324621},{"score":6,"gcsescore":7.5,"count":0.158215717023872},{"score":6,"gcsescore":8,"count":0.014288203519777},{"score":8,"gcsescore":0.5,"count":0},{"score":8,"gcsescore":1,"count":0},{"score":8,"gcsescore":1.5,"count":0},{"score":8,"gcsescore":2,"count":0},{"score":8,"gcsescore":2.5,"count":0.0002999400119976},{"score":8,"gcsescore":3,"count":0},{"score":8,"gcsescore":3.5,"count":0.0002999400119976},{"score":8,"gcsescore":4,"count":0.0020995800839832},{"score":8,"gcsescore":4.5,"count":0.00719856028794241},{"score":8,"gcsescore":5,"count":0.023995200959808},{"score":8,"gcsescore":5.5,"count":0.0737852429514097},{"score":8,"gcsescore":6,"count":0.236952609478104},{"score":8,"gcsescore":6.5,"count":0.476004799040192},{"score":8,"gcsescore":7,"count":0.716856628674265},{"score":8,"gcsescore":7.5,"count":0.394121175764847},{"score":8,"gcsescore":8,"count":0.0683863227354529},{"score":10,"gcsescore":0.5,"count":0},{"score":10,"gcsescore":1,"count":0},{"score":10,"gcsescore":1.5,"count":0},{"score":10,"gcsescore":2,"count":0},{"score":10,"gcsescore":2.5,"count":0},{"score":10,"gcsescore":3,"count":0.000299356383774884},{"score":10,"gcsescore":3.5,"count":0},{"score":10,"gcsescore":4,"count":0.000299356383774884},{"score":10,"gcsescore":4.5,"count":0.00119742553509954},{"score":10,"gcsescore":5,"count":0.00478970214039814},{"score":10,"gcsescore":5.5,"count":0.0125729681185451},{"score":10,"gcsescore":6,"count":0.0676545427331238},{"score":10,"gcsescore":6.5,"count":0.182906750486454},{"score":10,"gcsescore":7,"count":0.552611884448436},{"score":10,"gcsescore":7.5,"count":0.715162400838198},{"score":10,"gcsescore":8,"count":0.462505612932196}];
    
  var subCharts = [];  
  
  //move this here for facet template since only occurs once
  //allow manipulation of default colors to use with dimple
  if(opts.defaultColors.length) {
    opts.defaultColors = opts.defaultColors[0];
    if (typeof(opts.defaultColors) == "function") {
      //assume this is a d3 scale
      //for now loop through first 20 but need a better way to handle
      defaultColorsArray = [];
      for (var n=0;n<20;n++) {
        defaultColorsArray.push(opts.defaultColors(n));
      };
      opts.defaultColors = defaultColorsArray;
    }
    opts.defaultColors.forEach(function(d,i) {
      opts.defaultColors[i] = new dimple.color(d);
    })
  }
  
  var c = null;
  
  function buildSeries(layer, hidden, myChart){
      var x = buildAxis("x", layer, myChart);
      x.hidden = hidden;
      
      var y = buildAxis("y", layer, myChart);
      y.hidden = hidden;
      
      //z for bubbles
      var z = null;
      if (!(typeof(layer.zAxis) === 'undefined') && layer.zAxis.type){
        z = buildAxis("z", layer, myChart);
      };
      
      //here think I need to evaluate group and if missing do null
      //as the group argument
      //if provided need to use groups from layer
      var s = new dimple.series(myChart, null, x, y, z, c, dimple.plot[layer.type], dimple.aggregateMethod.avg, dimple.plot[layer.type].stacked);
      
      if(layer.hasOwnProperty("groups")) {
        s.categoryFields = (typeof layer.groups === "object") ? layer.groups : [layer.groups];
        //series offers an aggregate method that we will also need to check if available
        //options available are avg, count, max, min, sum
        if (!(typeof(layer.aggregate) === 'undefined')) {
          s.aggregate = eval(layer.aggregate);
        }
        if (!(typeof(layer.lineWeight) === 'undefined')) {
          s.lineWeight = eval(layer.lineWeight);
        }
        if (!(typeof(layer.barGap) === 'undefined')) {
          s.barGap = eval(layer.barGap);
        }    
      };
      myChart.series.push(s);
      return s;
    };
    
  //function to build axes
  function buildAxis(position,layer,myChart){
    var axis;
    var axisopts = opts[position+"Axis"];
    
    if(axisopts.measure) {
      axis = myChart[axisopts.type](position,layer[position],axisopts.measure);
    } else {
      axis = myChart[axisopts.type](position, layer[position]);
    };
    if(!(axisopts.type === "addPctAxis")) axis.showPercent = axisopts.showPercent;
    if (axisopts.orderRule) axis.addOrderRule(axisopts.orderRule);
    if (axisopts.grouporderRule) axis.addGroupOrderRule(axisopts.grouporderRule);  
    if (axisopts.overrideMin) axis.overrideMin = axisopts.overrideMin;
    if (axisopts.overrideMax) axis.overrideMax = axisopts.overrideMax;
    if (axisopts.overrideMax) axis.overrideMax = axisopts.overrideMax;
    if (axisopts.inputFormat) axis.dateParseFormat = axisopts.inputFormat;
    if (axisopts.outputFormat) axis.tickFormat = axisopts.outputFormat;    
    return axis;
  };
      
      

  

  //if facet not provided for x or y make Dummy variable
  opts.facet.x = opts.facet.x ? opts.facet.x : "Dummy"
  opts.facet.y = opts.facet.y ? opts.facet.y : "Dummy"    
  if(opts.facet.x === "Dummy" || opts.facet.y === "Dummy") {
    data.forEach(function(d){
      d.Dummy = 1;
    })
  }

  var rows = d3.set(data.map(function(d){return d[opts.facet.y]})).values();
  var nrow = opts.facet.nrow ? opts.facet.nrow : rows.length;
  var cols = d3.set(data.map(function(d){return d[opts.facet.x]})).values()
  var ncol = opts.facet.ncol ? opts.facet.ncol : cols.length;
  
  var tuples = d3.merge(rows.map(function(row,irow){return cols.map(function(col,icol){return {key:row + "~" + col, values: {"row":irow, "col":icol} }})}))
    
  var grid = d3.layout.grid()
    .rows( nrow )
    .cols( ncol )
    .size([ opts.width, opts.height-100])
    .bands();
  
  var svgGrid = d3.select("#" + opts.id).append("svg")
    .attr("width", opts.width)
    .attr("height", opts.height);
   // .attr("transform", "translate(50,0)");

grid(tuples);

/* var cells = d3.select("#" + opts.id).selectAll("svg")
    .data(grid(tuples))
    .enter()
      .append("svg")
        .attr("class", "cell")
        .attr("id", function(d) {
          return d.key;
        })
        .attr("transform", function(d, i) {
           return "translate(" + d.x + "," + d.y + ")"
         })
        .attr("width", grid.nodeSize()[0])
        .attr("height", grid.nodeSize()[1]);
*/

  var color = d3.scale.linear()
    .domain([0, 3, 6])
    .range(["red", "lightgray", "green"]);
    
/*  cells.selectAll("rect")
    .data(function(d){
      return [d];
    })
      .enter().append("rect")
        .attr("width", grid.nodeSize()[0])
        .attr("height", grid.nodeSize()[1])
        .style("fill", function(d) {return color(d.values.row)});         
*/
    tuples.forEach(function(cell,cellnum) {
        //cell = d3.select(cell);
    
        // Filter the data set for the quarter and the price tier
        // of the current shape
        var filteredData = dimple.filterData(data, opts.facet.x, cell.key.split('~')[1]);
        filteredData = dimple.filterData(filteredData, opts.facet.y, cell.key.split('~')[0]);    
        
        // Draw a new chart which will go in the current shape
        var subChart = new dimple.chart(svgGrid, filteredData);

        
        // Get the shape from the main chart on which this chart is based
        var shape = d3.select(this);


        // Position the chart inside the shape
        subChart.setBounds(
            parseFloat(cell.x + 50), 
            parseFloat(cell.y + 10),
            parseFloat(grid.nodeSize()[0] - 50),
            parseFloat(grid.nodeSize()[1]) - 10);

  
  
  //dimple allows use of custom CSS with noFormats
  if(opts.noFormats) { subChart.noFormats = opts.noFormats; };
  
  //need to fix later for better colorAxis support
  if(d3.keys(opts.colorAxis).length > 0) {
    c = subChart[opts.colorAxis.type](opts.colorAxis.colorSeries,opts.colorAxis.palette) ;
  }

  
  //allow manipulation of default colors to use with dimple
  if(opts.defaultColors.length) {
    //move transform of defaultColors to top
    subChart.defaultColors = opts.defaultColors;
  }  
  
  buildSeries(opts, false, subChart);
  if (opts.layers.length > 0) {
    opts.layers.forEach(function(layer){
      buildSeries(layer, true, subChart);
    })
  }
  //unsure if this is best but if legend is provided (not empty) then evaluate
  if(d3.keys(opts.legend).length > 0) {
    var l =subChart.addLegend();
    d3.keys(opts.legend).forEach(function(d){
      l[d] = opts.legend[d];
    });
  }
  //quick way to get this going but need to make this cleaner
  if(opts.storyboard) {
    subChart.setStoryboard(opts.storyboard);
  };
  subChart.draw();
  subCharts.push(subChart);
})


//evaluate which do not fall in column 1 or row 1 to remove
var xpos = d3.extent(subCharts,function(d){return d.x});
var ypos = d3.extent(subCharts,function(d){return d.y});

//get rid of all y for those not in column 1
//can easily customize this to only remove bits and pieces
subCharts.filter(function(d){
  return d.x!=xpos[0];
}).forEach(function(d){
  d.axes[1].shapes.remove();
  d.axes[1].titleShape.remove();
});
//now x for those not in row 1
subCharts.filter(function(d){
  return d.y!=ypos[1];
}).forEach(function(d){
  d.axes[0].shapes.remove();
  d.axes[0].titleShape.remove();
});

/*
subCharts.filter(function(d){
  return d.svg.data()[0].values.col!=0;
}).forEach(function(d){
  d.axes[1].shapes.remove();
  d.axes[1].titleShape.remove();
});
//now x for those not in row 1
subCharts.filter(function(d){
  return d.svg.data()[0].values.row!=nrow-1;
}).forEach(function(d){
  d.axes[0].shapes.remove();
  d.axes[0].titleShape.remove();
});
*/

})();
</script>
    
    <script></script>    
  </body>
</html>
